<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Pixel Runner: Escape the Grid</title>
<style>
  /* Reset and base */
  * {
    margin: 0; padding: 0; box-sizing: border-box;
  }
  body, html {
    height: 100%; background: #111; color: #eee; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    overflow: hidden;
    user-select: none;
  }
  canvas {
    display: block; margin: auto; background: #111;
    border: 3px solid #333;
    image-rendering: pixelated;
  }
  #ui {
    position: fixed; top: 10px; left: 50%; transform: translateX(-50%);
    color: #eee; font-weight: 700; font-size: 18px;
    font-family: monospace;
    text-shadow: 0 0 6px #0ff;
    user-select: none;
  }
  #message {
    position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
    color: #0ff; font-size: 28px; font-weight: 900;
    font-family: monospace;
    text-align: center;
    text-shadow: 0 0 10px #0ff;
    display: none;
  }
  button {
    margin-top: 15px;
    background: #0ff;
    border: none;
    padding: 8px 15px;
    font-weight: 700;
    font-family: monospace;
    cursor: pointer;
    color: #111;
    border-radius: 5px;
    transition: background 0.3s;
  }
  button:hover {
    background: #1ff;
  }
</style>
</head>
<body>

<canvas id="game" width="400" height="600"></canvas>
<div id="ui">Score: 0 | Lives: 3</div>
<div id="message">
  <div id="msg-text"></div>
  <button id="restart-btn">Restart</button>
</div>

<script>
(() => {
  // Game constants
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const UI = document.getElementById('ui');
  const message = document.getElementById('message');
  const msgText = document.getElementById('msg-text');
  const restartBtn = document.getElementById('restart-btn');

  const WIDTH = canvas.width;
  const HEIGHT = canvas.height;

  // Player config
  const PLAYER_SIZE = 20;
  const PLAYER_SPEED = 5;

  // Enemy config
  const ENEMY_SIZE = 20;
  let ENEMY_SPEED = 2;

  // Obstacle config
  const OBSTACLE_WIDTH = 60;
  const OBSTACLE_GAP = 160;

  // Game state
  let score = 0;
  let lives = 3;
  let gameOver = false;

  // Input state
  let leftPressed = false;
  let rightPressed = false;

  // Player object
  const player = {
    x: WIDTH / 2 - PLAYER_SIZE / 2,
    y: HEIGHT - PLAYER_SIZE - 10,
    width: PLAYER_SIZE,
    height: PLAYER_SIZE,
    color: '#0ff',
    move() {
      if (leftPressed) this.x -= PLAYER_SPEED;
      if (rightPressed) this.x += PLAYER_SPEED;
      if (this.x < 0) this.x = 0;
      if (this.x + this.width > WIDTH) this.x = WIDTH - this.width;
    },
    draw() {
      ctx.fillStyle = this.color;
      ctx.fillRect(this.x, this.y, this.width, this.height);
      // glow effect
      ctx.shadowColor = '#0ff';
      ctx.shadowBlur = 10;
      ctx.fillRect(this.x, this.y, this.width, this.height);
      ctx.shadowBlur = 0;
    }
  };

  // Enemy class
  class Enemy {
    constructor(x, y, speed) {
      this.x = x;
      this.y = y;
      this.width = ENEMY_SIZE;
      this.height = ENEMY_SIZE;
      this.speed = speed;
      this.color = '#f00';
      this.direction = 1; // moves left/right
      this.moveCooldown = 0;
    }

    update() {
      // Simple horizontal zigzag movement within bounds
      this.x += this.speed * this.direction;
      if (this.x < 0) {
        this.x = 0;
        this.direction = 1;
      }
      if (this.x + this.width > WIDTH) {
        this.x = WIDTH - this.width;
        this.direction = -1;
      }
      // Move down slowly over time
      this.y += 0.1;

      // If enemy moves off screen bottom, reset top
      if (this.y > HEIGHT) {
        this.y = -ENEMY_SIZE;
        this.x = Math.random() * (WIDTH - ENEMY_SIZE);
        score++;
        increaseDifficulty();
      }
    }

    draw() {
      ctx.fillStyle = this.color;
      ctx.fillRect(this.x, this.y, this.width, this.height);
      // glow red
      ctx.shadowColor = '#f00';
      ctx.shadowBlur = 15;
      ctx.fillRect(this.x, this.y, this.width, this.height);
      ctx.shadowBlur = 0;
    }
  }

  // Obstacle class
  class Obstacle {
    constructor(y) {
      this.y = y;
      this.width = OBSTACLE_WIDTH;
      this.height = 20;
      this.color = '#555';
      this.x = Math.random() * (WIDTH - this.width);
      this.speed = 2;
    }
    update() {
      this.y += this.speed;
      if (this.y > HEIGHT) {
        this.y = -this.height;
        this.x = Math.random() * (WIDTH - this.width);
        score++;
        increaseDifficulty();
      }
    }
    draw() {
      ctx.fillStyle = this.color;
      ctx.fillRect(this.x, this.y, this.width, this.height);
      // subtle shadow
      ctx.shadowColor = '#333';
      ctx.shadowBlur = 5;
      ctx.fillRect(this.x, this.y, this.width, this.height);
      ctx.shadowBlur = 0;
    }
  }

  // Create enemies
  let enemies = [];
  for (let i = 0; i < 5; i++) {
    enemies.push(new Enemy(Math.random() * (WIDTH - ENEMY_SIZE), -Math.random() * HEIGHT, ENEMY_SPEED));
  }

  // Create obstacles
  let obstacles = [];
  for (let i = 0; i < 3; i++) {
    obstacles.push(new Obstacle(-i * 200));
  }

  // Increase difficulty function
  function increaseDifficulty() {
    if (score % 5 === 0 && ENEMY_SPEED < 7) {
      ENEMY_SPEED += 0.3;
      enemies.forEach(e => e.speed = ENEMY_SPEED);
      obstacles.forEach(o => o.speed += 0.2);
    }
  }

  // Collision detection (AABB)
  function isColliding(a, b) {
    return (
      a.x < b.x + b.width &&
      a.x + a.width > b.x &&
      a.y < b.y + b.height &&
      a.y + a.height > b.y
    );
  }

  // Handle collisions and lives
  function checkCollisions() {
    // Enemy collisions
    for (let enemy of enemies) {
      if (isColliding(player, enemy)) {
        lives--;
        resetPositions();
        if (lives <= 0) {
          endGame();
          return;
        }
      }
    }
    // Obstacle collisions
    for (let obstacle of obstacles) {
      if (isColliding(player, obstacle)) {
        lives--;
        resetPositions();
        if (lives <= 0) {
          endGame();
          return;
        }
      }
    }
  }

  // Reset player and enemies position after hit
  function resetPositions() {
    player.x = WIDTH / 2 - PLAYER_SIZE / 2;
    player.y = HEIGHT - PLAYER_SIZE - 10;
    enemies.forEach(e => {
      e.y = -Math.random() * HEIGHT;
      e.x = Math.random() * (WIDTH - ENEMY_SIZE);
    });
    obstacles.forEach(o => {
      o.y = -Math.random() * HEIGHT;
      o.x = Math.random() * (WIDTH - o.width);
    });
  }

  // Game over
  function endGame() {
    gameOver = true;
    message.style.display = 'block';
    msgText.textContent = `GAME OVER\nFinal Score: ${score}`;
  }

  // Restart game
  function restartGame() {
    score = 0;
    lives = 3;
    ENEMY_SPEED = 2;
    enemies.forEach(e => e.speed = ENEMY_SPEED);
    obstacles.forEach(o => o.speed = 2);
    resetPositions();
    gameOver = false;
    message.style.display = 'none';
  }

  restartBtn.addEventListener('click', () => {
    restartGame();
    requestAnimationFrame(gameLoop);
  });

  // Input events
  window.addEventListener('keydown', e => {
    if (e.key === 'ArrowLeft' || e.key === 'a') leftPressed = true;
    if (e.key === 'ArrowRight' || e.key === 'd') rightPressed = true;
  });
  window.addEventListener('keyup', e => {
    if (e.key === 'ArrowLeft' || e.key === 'a') leftPressed = false;
    if (e.key === 'ArrowRight' || e.key === 'd') rightPressed = false;
  });

  // Game loop
  function gameLoop() {
    if (gameOver) return;

    // Clear canvas
    ctx.clearRect(0, 0, WIDTH, HEIGHT);

    // Update player
    player.move();
    player.draw();

    // Update enemies
    enemies.forEach(enemy => {
      enemy.update();
      enemy.draw();
    });

    // Update obstacles
    obstacles.forEach(obstacle => {
      obstacle.update();
      obstacle.draw();
    });

    // Check collisions
    checkCollisions();

    // Draw UI
    UI.textContent = `Score: ${score} | Lives: ${lives}`;

    // Next frame
    requestAnimationFrame(gameLoop);
  }

  // Start the game
  resetPositions();
  requestAnimationFrame(gameLoop);
})();
</script>

</body>
</html>
