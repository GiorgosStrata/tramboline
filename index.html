<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Trampoline Physics Simulator - Balanced</title>
<style>
  /* Reset & base */
  * {
    margin: 0; padding: 0; box-sizing: border-box;
  }
  body, html {
    width: 100%; height: 100%;
    overflow: hidden;
    background: linear-gradient(to top, #1e2a47 0%, #4e668f 100%);
    font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
    user-select: none;
    touch-action: manipulation;
    color: #ddd;
    display: flex;
    justify-content: center;
    align-items: center;
  }

  /* Container to hold 9:16 canvas */
  #container {
    width: 100vh; /* Use viewport height as width base */
    max-width: 100vw;
    aspect-ratio: 9 / 16;
    background: #192a4f;
    position: relative;
    box-shadow: 0 0 30px rgba(78, 102, 143, 0.8);
    border-radius: 20px;
    overflow: hidden;
    display: flex;
    flex-direction: column;
  }

  /* UI container */
  #ui {
    position: absolute;
    top: 12px; left: 50%;
    transform: translateX(-50%);
    background: rgba(30, 45, 70, 0.85);
    border-radius: 14px;
    display: flex;
    gap: 16px;
    padding: 10px 18px;
    box-shadow: 0 4px 10px rgba(100, 130, 180, 0.5);
    z-index: 1000;
    flex-wrap: wrap;
    justify-content: center;
    user-select: none;
  }

  /* Shape buttons */
  .shape-btn {
    background: #324a77;
    border: 2px solid #a3b8e2;
    border-radius: 8px;
    color: #a3b8e2;
    padding: 8px 20px;
    cursor: pointer;
    font-weight: 600;
    transition: all 0.25s ease;
  }
  .shape-btn.selected,
  .shape-btn:hover {
    background: #a3b8e2;
    color: #324a77;
    box-shadow: 0 0 10px #a3b8e2;
  }

  /* Planet selector */
  select {
    background: #324a77;
    color: #a3b8e2;
    border: 2px solid #a3b8e2;
    border-radius: 8px;
    padding: 6px 14px;
    font-weight: 600;
    cursor: pointer;
    user-select: none;
    transition: all 0.25s ease;
  }
  select:hover {
    background: #a3b8e2;
    color: #324a77;
    box-shadow: 0 0 10px #a3b8e2;
  }

  /* Canvas styling */
  canvas {
    flex: 1;
    background: #15263d;
    touch-action: none;
    display: block;
  }

  /* Info text */
  #info {
    position: absolute;
    bottom: 10px; left: 50%;
    transform: translateX(-50%);
    color: #a3b8e2;
    font-weight: 600;
    font-size: 14px;
    font-family: monospace;
    text-shadow: 0 0 3px #12233c;
    user-select: none;
    z-index: 1000;
  }
</style>
</head>
<body>

<div id="container">
  <div id="ui" aria-label="Controls">
    <button class="shape-btn selected" data-shape="circle" aria-pressed="true" title="Circle shape">Circle</button>
    <button class="shape-btn" data-shape="square" aria-pressed="false" title="Square shape">Square</button>
    <select id="planet-select" aria-label="Select Planet Gravity">
      <option value="earth" selected>Earth</option>
      <option value="moon">Moon</option>
      <option value="jupiter">Jupiter</option>
    </select>
  </div>

  <canvas id="game" role="main" aria-label="Trampoline physics simulation"></canvas>
  <div id="info">Left click/tap: Place shape | Drag: Aim preview | Right click / Two-finger tap: Cancel placement</div>
</div>

<script>
(() => {
  const container = document.getElementById('container');
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  // Physics params per planet
  const gravityMap = {
    earth: 0.6,
    moon: 0.1,
    jupiter: 1.6,
  };

  // Current physics gravity
  let gravity = gravityMap.earth;

  // Trampoline params
  let trampoline = {
    x: 0,
    y: 0,
    width: 0,
    height: 30,
    baseHeight: 30,
    squash: 0,
    squashSpeed: 0.3,
  };

  // Shapes array
  const shapes = [];

  // Currently selected shape
  let currentShape = 'circle';

  // Placement preview data
  let placingShape = null; // {x, y, type}
  let isPlacing = false;

  // Track pointer position for drag aiming
  let pointerStart = null;
  let pointerCurrent = null;

  // Responsive resize inside container with 9:16 aspect ratio
  function resize() {
    canvas.width = container.clientWidth;
    canvas.height = container.clientHeight;
    trampoline.width = canvas.width * 0.5;
    trampoline.x = canvas.width / 2;
    trampoline.y = canvas.height - trampoline.height;
  }
  window.addEventListener('resize', resize);
  resize();

  // Select shape UI handlers
  const shapeButtons = document.querySelectorAll('.shape-btn');
  shapeButtons.forEach(btn => {
    btn.addEventListener('click', () => {
      shapeButtons.forEach(b => {
        b.classList.remove('selected');
        b.setAttribute('aria-pressed', 'false');
      });
      btn.classList.add('selected');
      btn.setAttribute('aria-pressed', 'true');
      currentShape = btn.dataset.shape;
      cancelPlacement();
    });
  });

  // Planet selection UI
  const planetSelect = document.getElementById('planet-select');
  planetSelect.addEventListener('change', e => {
    gravity = gravityMap[e.target.value];
    // Change background based on planet
    switch(e.target.value) {
      case 'earth':
        container.style.background = 'linear-gradient(to top, #1e2a47 0%, #4e668f 100%)';
        break;
      case 'moon':
        container.style.background = 'linear-gradient(to top, #3a3a4a 0%, #888899 100%)';
        break;
      case 'jupiter':
        container.style.background = 'linear-gradient(to top, #553311 0%, #aa7744 100%)';
        break;
    }
  });

  // Shape class
  class Shape {
    constructor(x, y, type) {
      this.x = x;
      this.y = y;
      this.type = type;
      this.size = 40;
      this.mass = 1; // could expand later
      this.vx = 0;  // no horizontal drift anymore
      this.vy = 0;
      this.color = type === 'circle' ? '#7bb4e2' : '#9a8fcc';
      this.bounceEnergyLoss = 0.75; // energy lost each bounce
    }

    update() {
      // Apply gravity
      this.vy += gravity;

      // Move
      this.x += this.vx;
      this.y += this.vy;

      // Collide with walls (only vertical motion, but keep horizontal inside)
      if(this.x - this.size/2 < 0) {
        this.x = this.size/2;
      }
      if(this.x + this.size/2 > canvas.width) {
        this.x = canvas.width - this.size/2;
      }

      // Floor collision
      if(this.y + this.size/2 > canvas.height) {
        this.y = canvas.height - this.size/2;
        if(Math.abs(this.vy) > 1) {
          this.vy = -Math.abs(this.vy) * this.bounceEnergyLoss;
          triggerTrampolineSquash();
        } else {
          this.vy = 0;
        }
      }

      // Trampoline collision (AABB + circle approximation)
      if(
        this.x > trampoline.x - trampoline.width/2 &&
        this.x < trampoline.x + trampoline.width/2 &&
        this.y + this.size/2 > trampoline.y - trampoline.height &&
        this.y + this.size/2 < trampoline.y &&
        this.vy > 0
      ) {
        this.y = trampoline.y - trampoline.height - this.size/2;
        if(Math.abs(this.vy) > 1) {
          this.vy = -Math.abs(this.vy) * this.bounceEnergyLoss;
          triggerTrampolineSquash();
        } else {
          this.vy = 0;
        }
      }
    }

    draw() {
      ctx.fillStyle = this.color;
      ctx.strokeStyle = '#233650';
      ctx.lineWidth = 2;
      ctx.beginPath();
      if(this.type === 'circle') {
        ctx.ellipse(this.x, this.y, this.size/2, this.size/2, 0, 0, 2 * Math.PI);
      } else if(this.type === 'square') {
        ctx.rect(this.x - this.size/2, this.y - this.size/2, this.size, this.size);
      }
      ctx.fill();
      ctx.stroke();
    }
  }

  // Squash trampoline animation trigger
  function triggerTrampolineSquash() {
    trampoline.squash = 1;
  }

  // Main draw trampoline function
  function drawTrampoline() {
    const baseY = trampoline.y;
    const width = trampoline.width;
    const height = trampoline.height;

    // Squash decay
    trampoline.squash *= 0.85;
    if(trampoline.squash < 0.01) trampoline.squash = 0;

    // Squash height change
    const squashHeight = height + trampoline.squash * 15;

    // Draw trampoline surface (elastic-like)
    ctx.fillStyle = '#4e7ac7';
    ctx.strokeStyle = '#2c4b7a';
    ctx.lineWidth = 3;
    ctx.beginPath();

    // Left corner
    ctx.moveTo(trampoline.x - width/2, baseY);
    // Bezier curve for trampoline stretch
    ctx.bezierCurveTo(
      trampoline.x - width/4, baseY + squashHeight,
      trampoline.x + width/4, baseY + squashHeight,
      trampoline.x + width/2, baseY
    );

    // Bottom line to close shape
    ctx.lineTo(trampoline.x + width/2, baseY + height);
    ctx.lineTo(trampoline.x - width/2, baseY + height);
    ctx.closePath();

    ctx.fill();
    ctx.stroke();

    // Draw trampoline legs
    ctx.strokeStyle = '#22375e';
    ctx.lineWidth = 4;
    const legHeight = 60;
    ctx.beginPath();
    ctx.moveTo(trampoline.x - width/2 + 10, baseY + height);
    ctx.lineTo(trampoline.x - width/2 + 10, baseY + height + legHeight);
    ctx.moveTo(trampoline.x + width/2 - 10, baseY + height);
    ctx.lineTo(trampoline.x + width/2 - 10, baseY + height + legHeight);
    ctx.stroke();
  }

  // Placement preview
  function drawPlacementPreview() {
    if(!isPlacing || !placingShape) return;
    const x = pointerCurrent ? pointerCurrent.x : placingShape.x;
    const y = pointerCurrent ? pointerCurrent.y : placingShape.y;
    ctx.save();
    ctx.globalAlpha = 0.5;
    ctx.fillStyle = placingShape.type === 'circle' ? '#a0c0ff' : '#c9baff';
    ctx.strokeStyle = '#4a6a9f';
    ctx.lineWidth = 2;
    ctx.beginPath();
    const size = 40;
    if(placingShape.type === 'circle') {
      ctx.ellipse(x, y, size/2, size/2, 0, 0, 2 * Math.PI);
    } else if(placingShape.type === 'square') {
      ctx.rect(x - size/2, y - size/2, size, size);
    }
    ctx.fill();
    ctx.stroke();
    ctx.restore();
  }

  // Clear cancel placement
  function cancelPlacement() {
    isPlacing = false;
    placingShape = null;
    pointerStart = null;
    pointerCurrent = null;
  }

  // Main loop
  function loop() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw trampoline
    drawTrampoline();

    // Update + draw all shapes
    shapes.forEach(shape => {
      shape.update();
      shape.draw();
    });

    // Draw preview if placing
    drawPlacementPreview();

    requestAnimationFrame(loop);
  }
  loop();

  // Input handling for placing shapes
  function getPointerPos(evt) {
    let rect = canvas.getBoundingClientRect();
    let x, y;
    if(evt.touches && evt.touches.length > 0) {
      x = evt.touches[0].clientX - rect.left;
      y = evt.touches[0].clientY - rect.top;
    } else {
      x = evt.clientX - rect.left;
      y = evt.clientY - rect.top;
    }
    // Clamp inside canvas
    x = Math.min(Math.max(0, x), canvas.width);
    y = Math.min(Math.max(0, y), canvas.height);
    return {x, y};
  }

  // Left mouse / tap down starts placement
  canvas.addEventListener('pointerdown', (e) => {
    if(e.button !== 2) { // Not right click
      pointerStart = getPointerPos(e);
      pointerCurrent = pointerStart;
      placingShape = { x: pointerStart.x, y: pointerStart.y, type: currentShape };
      isPlacing = true;
      e.preventDefault();
    }
  }, {passive:false});

  // Drag to move preview
  canvas.addEventListener('pointermove', (e) => {
    if(isPlacing) {
      pointerCurrent = getPointerPos(e);
      placingShape.x = pointerCurrent.x;
      placingShape.y = pointerCurrent.y;
    }
  }, {passive:true});

  // Release left click to place shape
  canvas.addEventListener('pointerup', (e) => {
    if(isPlacing && e.button !== 2) {
      // Place shape at pointerCurrent.x and y, but always start above trampoline for fall
      let placeX = placingShape.x;
      // Start above trampoline by 50px (to see bounce)
      let placeY = trampoline.y - trampoline.height - 50;

      shapes.push(new Shape(placeX, placeY, placingShape.type));

      cancelPlacement();
    }
  });

  // Right click or two-finger tap to cancel
  canvas.addEventListener('contextmenu', (e) => {
    cancelPlacement();
    e.preventDefault();
  });

  // Mobile two-finger tap cancel
  let lastTouchTime = 0;
  canvas.addEventListener('touchstart', (e) => {
    if(e.touches.length === 2) {
      let now = Date.now();
      if(now - lastTouchTime < 500) {
        cancelPlacement();
      }
      lastTouchTime = now;
    }
  });

})();
</script>
</body>
</html>
